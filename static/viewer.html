<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open3D 3D Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }
        
        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(20, 20, 30, 0.95);
            border-bottom: 1px solid rgba(0, 200, 150, 0.3);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .logo {
            font-size: 18px;
            font-weight: bold;
            color: #00c896;
            margin-right: 30px;
        }
        
        .logo span {
            color: #00aaff;
        }
        
        /* Job selector */
        .job-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .job-selector label {
            color: #888;
            font-size: 12px;
        }
        
        .job-selector select {
            background: rgba(30, 30, 45, 0.9);
            border: 1px solid rgba(0, 200, 150, 0.3);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 12px;
            min-width: 250px;
            cursor: pointer;
        }
        
        .job-selector select:focus {
            outline: none;
            border-color: #00c896;
        }
        
        /* View controls */
        .view-controls {
            display: flex;
            gap: 5px;
            margin-left: 20px;
        }
        
        .view-btn {
            background: rgba(40, 40, 60, 0.9);
            border: 1px solid rgba(100, 100, 120, 0.3);
            color: #888;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .view-btn:hover {
            border-color: rgba(0, 200, 150, 0.5);
            color: #ccc;
        }
        
        .view-btn.active {
            background: rgba(0, 200, 150, 0.2);
            border-color: #00c896;
            color: #00c896;
        }
        
        .view-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        /* Stats */
        .stats {
            margin-left: auto;
            display: flex;
            gap: 20px;
            font-size: 11px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-value {
            color: #00c896;
            font-size: 14px;
            font-weight: bold;
        }
        
        .stat-label {
            color: #666;
            font-size: 10px;
        }
        
        /* 3D Canvas */
        #viewer-container {
            position: fixed;
            top: 50px;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        #canvas-3d {
            width: 100%;
            height: 100%;
        }
        
        /* Side Panel */
        .side-panel {
            position: fixed;
            top: 60px;
            right: 10px;
            width: 260px;
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid rgba(0, 200, 150, 0.2);
            border-radius: 8px;
            padding: 15px;
            backdrop-filter: blur(10px);
            z-index: 50;
        }
        
        .panel-title {
            color: #00c896;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 200, 150, 0.2);
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 11px;
        }
        
        .info-label {
            color: #666;
        }
        
        .info-value {
            color: #ccc;
            font-weight: 500;
        }
        
        .info-value.success {
            color: #00c896;
        }
        
        .info-value.warning {
            color: #ffaa00;
        }
        
        /* RFID List */
        .rfid-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .rfid-item {
            background: rgba(40, 40, 60, 0.5);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 5px;
            font-size: 10px;
        }
        
        .rfid-epc {
            color: #00aaff;
            font-family: monospace;
            word-break: break-all;
        }
        
        .rfid-rssi {
            color: #888;
            margin-top: 4px;
        }
        
        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 50px;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 15, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        .loading-overlay.hidden {
            display: none;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 200, 150, 0.2);
            border-top-color: #00c896;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 15px;
            color: #888;
            font-size: 12px;
        }
        
        /* Controls help */
        .controls-help {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(20, 20, 30, 0.8);
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 10px;
            color: #666;
            z-index: 50;
        }
        
        .controls-help kbd {
            background: rgba(60, 60, 80, 0.5);
            padding: 2px 6px;
            border-radius: 3px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="logo">Open3D <span>Viewer</span></div>
        
        <div class="job-selector">
            <label>JOB:</label>
            <select id="job-select">
                <option value="">-- Select a job --</option>
            </select>
        </div>
        
        <div class="view-controls">
            <button id="btn-pointcloud" class="view-btn active" disabled>Point Cloud</button>
            <button id="btn-mesh" class="view-btn" disabled>Mesh</button>
            <button id="btn-rfid" class="view-btn" disabled>RFID</button>
            <button id="btn-trajectory" class="view-btn" disabled>Trajectory</button>
        </div>
        
        <div class="stats">
            <div class="stat">
                <span class="stat-value" id="point-count">0</span>
                <span class="stat-label">Points</span>
            </div>
            <div class="stat">
                <span class="stat-value" id="face-count">0</span>
                <span class="stat-label">Faces</span>
            </div>
            <div class="stat">
                <span class="stat-value" id="rfid-count">0</span>
                <span class="stat-label">RFIDs</span>
            </div>
            <div class="stat">
                <span class="stat-value" id="trajectory-count">0</span>
                <span class="stat-label">Poses</span>
            </div>
        </div>
    </header>
    
    <!-- 3D Viewer -->
    <div id="viewer-container">
        <canvas id="canvas-3d"></canvas>
    </div>
    
    <!-- Side Panel -->
    <div class="side-panel">
        <div class="panel-title">JOB INFO</div>
        <div class="info-row">
            <span class="info-label">Job ID:</span>
            <span class="info-value" id="info-job-id">-</span>
        </div>
        <div class="info-row">
            <span class="info-label">Status:</span>
            <span class="info-value success" id="info-status">-</span>
        </div>
        <div class="info-row">
            <span class="info-label">Mode:</span>
            <span class="info-value" id="info-mode">-</span>
        </div>
        <div class="info-row">
            <span class="info-label">Depth Source:</span>
            <span class="info-value" id="info-depth-source">-</span>
        </div>
        
        <div class="panel-title" style="margin-top: 15px;">RFID DETECTIONS</div>
        <div class="rfid-list" id="rfid-list">
            <div style="color: #666; font-size: 11px;">No RFID data</div>
        </div>
    </div>
    
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loading-text">Loading...</div>
    </div>
    
    <!-- Controls Help -->
    <div class="controls-help">
        <kbd>Drag</kbd> Rotate &nbsp;
        <kbd>Scroll</kbd> Zoom &nbsp;
        <kbd>Right-drag</kbd> Pan &nbsp;
        <kbd>R</kbd> Reset
    </div>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/PLYLoader.js"></script>
    <script>
        // サービスワーカーのエラーを無視（ブラウザ拡張機能によるもの）
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                for(let registration of registrations) {
                    registration.unregister();
                }
            }).catch(function(error) {
                // エラーを無視
            });
        }
        
        // OrbitControlsとPLYLoaderがグローバルに利用可能になるまで待つ
        if (typeof THREE !== 'undefined') {
            // OrbitControlsとPLYLoaderはexamples/jsから読み込まれる
            console.log('Three.js loaded');
        }
        
        // 未処理のPromiseエラーをキャッチ（サービスワーカーのエラーを無視）
        window.addEventListener('unhandledrejection', function(event) {
            if (event.reason && event.reason.message && 
                event.reason.message.includes('Could not establish connection')) {
                // サービスワーカー関連のエラーを無視
                event.preventDefault();
                console.log('Ignored service worker error');
            }
        });
    </script>
    
    <script>
        // ============================================================
        // Configuration
        // ============================================================
        const API_BASE = window.location.origin;
        
        // ============================================================
        // State
        // ============================================================
        let scene, camera, renderer, controls;
        let pointCloud = null;
        let mesh = null;
        let rfidMarkers = [];
        let currentJobId = null;
        let availableFiles = {};
        let displayMode = 'pointcloud'; // pointcloud, mesh, rfid
        
        // ============================================================
        // Initialization
        // ============================================================
        function initViewer() {
            const container = document.getElementById('viewer-container');
            const canvas = document.getElementById('canvas-3d');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.01,
                1000
            );
            camera.position.set(2, 2, 2);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.screenSpacePanning = true;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);
            
            // Grid
            const gridHelper = new THREE.GridHelper(10, 50, 0x00c896, 0x1a1a2e);
            gridHelper.position.y = -0.01;
            scene.add(gridHelper);
            
            // Axes
            const axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);
            
            // Events
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            
            // Start render loop
            animate();
        }
        
        function onWindowResize() {
            const container = document.getElementById('viewer-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function onKeyDown(event) {
            if (event.key === 'r' || event.key === 'R') {
                controls.reset();
                camera.position.set(2, 2, 2);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // ============================================================
        // Loading UI
        // ============================================================
        function showLoading(text = 'Loading...') {
            document.getElementById('loading-text').textContent = text;
            document.getElementById('loading-overlay').classList.remove('hidden');
        }
        
        function hideLoading() {
            document.getElementById('loading-overlay').classList.add('hidden');
        }
        
        // ============================================================
        // Job Loading
        // ============================================================
        async function loadJobList() {
            try {
                console.log('Loading job list from:', `${API_BASE}/api/v1/jobs`);
                const response = await fetch(`${API_BASE}/api/v1/jobs`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Job list response:', data);
                
                const select = document.getElementById('job-select');
                select.innerHTML = '<option value="">-- Select a job --</option>';
                
                const jobs = data.jobs || {};
                console.log('Jobs found:', Object.keys(jobs).length);
                
                // 完了したジョブだけでなく、すべてのジョブを表示（処理中も含む）
                const sortedJobs = Object.entries(jobs)
                    .sort((a, b) => {
                        const dateA = a[1].created_at ? new Date(a[1].created_at) : new Date(0);
                        const dateB = b[1].created_at ? new Date(b[1].created_at) : new Date(0);
                        return dateB - dateA;
                    });
                
                console.log('Sorted jobs:', sortedJobs.length);
                
                for (const [jobId, job] of sortedJobs) {
                    const option = document.createElement('option');
                    option.value = jobId;
                    const date = job.created_at ? new Date(job.created_at).toLocaleString() : 'Unknown';
                    const mode = job.mode ? ` [${job.mode.toUpperCase()}]` : '';
                    const status = job.status ? ` [${job.status.toUpperCase()}]` : '';
                    option.textContent = `${jobId}${mode}${status} (${date})`;
                    select.appendChild(option);
                }
                
                // 完了したジョブを優先的に選択
                const completedJobs = sortedJobs.filter(([id, job]) => job.status === 'completed');
                
                // Auto-select from URL
                const urlParams = new URLSearchParams(window.location.search);
                const urlJobId = urlParams.get('job_id');
                
                if (urlJobId && sortedJobs.some(([id]) => id === urlJobId)) {
                    select.value = urlJobId;
                    loadJob(urlJobId);
                } else if (completedJobs.length > 0) {
                    // 最新の完了したジョブを自動選択
                    select.value = completedJobs[0][0];
                    loadJob(completedJobs[0][0]);
                } else if (sortedJobs.length > 0) {
                    // 完了していなくても最新のジョブを選択
                    select.value = sortedJobs[0][0];
                    loadJob(sortedJobs[0][0]);
                } else {
                    console.log('No jobs found');
                    hideLoading();
                    select.innerHTML = '<option value="">-- No jobs available --</option>';
                }
                
            } catch (error) {
                console.error('Failed to load jobs:', error);
                const select = document.getElementById('job-select');
                select.innerHTML = '<option value="">-- Error loading jobs --</option>';
                hideLoading();
                
                // エラーメッセージを表示
                const errorMsg = error.message || 'Unknown error';
                console.error('Error details:', errorMsg);
            }
        }
        
        async function loadJob(jobId) {
            if (!jobId) return;
            
            currentJobId = jobId;
            showLoading('Loading job...');
            clearScene();
            
            // Update info panel
            document.getElementById('info-job-id').textContent = jobId.substring(0, 8);
            
            try {
                // Get job info
                console.log('Loading job info from:', `${API_BASE}/scenes/${jobId}/info.json`);
                const infoResponse = await fetch(`${API_BASE}/scenes/${jobId}/info.json`);
                
                if (!infoResponse.ok) {
                    throw new Error(`Failed to load job info: ${infoResponse.status}`);
                }
                
                const info = await infoResponse.json();
                console.log('Job info:', info);
                
                document.getElementById('info-status').textContent = info.status || '-';
                document.getElementById('info-mode').textContent = (info.mode || '-').toUpperCase();
                
                availableFiles = info.available_files || {};
                
                // Determine depth source
                const depthSource = info.result?.depth_source || 'Unknown';
                document.getElementById('info-depth-source').textContent = depthSource;
                
                // Update buttons
                document.getElementById('btn-pointcloud').disabled = !availableFiles['point_cloud.ply'] && !availableFiles['point_cloud_simplified.ply'];
                document.getElementById('btn-mesh').disabled = !availableFiles['mesh.ply'] && !availableFiles['mesh_simplified.ply'];
                document.getElementById('btn-rfid').disabled = !availableFiles['rfid_positions.json'];
                
                // Load point cloud (simplified version if available)
                const pointCloudFile = availableFiles['point_cloud_simplified.ply'] ? 'point_cloud_simplified.ply' : 
                                      availableFiles['point_cloud.ply'] ? 'point_cloud.ply' : null;
                
                if (pointCloudFile) {
                    try {
                        await loadPointCloud(jobId, pointCloudFile);
                    } catch (error) {
                        console.error('Failed to load point cloud:', error);
                        const errorMsg = error.message || 'Unknown error';
                        if (errorMsg.includes('timeout') || errorMsg.includes('too large')) {
                            showLoading('Point cloud is too large. Please try loading the mesh instead.');
                        } else {
                            showLoading('Failed to load point cloud. Trying mesh...');
                        }
                        // メモリクリーンアップ
                        if (pointCloud) {
                            scene.remove(pointCloud);
                            pointCloud.geometry?.dispose();
                            pointCloud.material?.dispose();
                            pointCloud = null;
                        }
                    }
                }
                
                // Load mesh (simplified version if available, only if point cloud failed or not available)
                const meshFile = availableFiles['mesh_simplified.ply'] ? 'mesh_simplified.ply' : 
                                 availableFiles['mesh.ply'] ? 'mesh.ply' : null;
                
                if (meshFile) {
                    // 点群がロードできなかった場合のみメッシュを試す
                    if (!pointCloud) {
                        showLoading('Loading mesh...');
                        try {
                            await loadMesh(jobId, meshFile);
                        } catch (error) {
                            console.error('Failed to load mesh:', error);
                            const errorMsg = error.message || 'Unknown error';
                            if (errorMsg.includes('timeout') || errorMsg.includes('too large') || errorMsg.includes('memory')) {
                                showLoading('Mesh is too large to load in browser. Please download the file directly.');
                            } else {
                                showLoading('Failed to load mesh');
                            }
                            // メモリクリーンアップ
                            if (mesh) {
                                scene.remove(mesh);
                                mesh.geometry?.dispose();
                                mesh.material?.dispose();
                                mesh = null;
                            }
                        }
                    } else {
                        // 点群がロードできた場合は、メッシュはオプションとして後でロード可能にする
                        console.log('Point cloud loaded successfully, skipping mesh to save memory');
                    }
                }
                
                // Load RFID
                if (availableFiles['rfid_positions.json']) {
                    showLoading('Loading RFID data...');
                    try {
                        await loadRFID(jobId);
                    } catch (error) {
                        console.error('Failed to load RFID:', error);
                    }
                    
                    // Load Trajectory
                    showLoading('Loading trajectory data...');
                    try {
                        await loadTrajectory(jobId);
                    } catch (error) {
                        console.error('Failed to load trajectory:', error);
                    }
                }
                
                // Set display mode
                if (pointCloud) {
                    setDisplayMode('pointcloud');
                } else if (mesh) {
                    setDisplayMode('mesh');
                }
                
            } catch (error) {
                console.error('Failed to load job:', error);
                showLoading('Error: ' + (error.message || 'Unknown error'));
                setTimeout(() => hideLoading(), 3000);
            } finally {
                hideLoading();
            }
        }
        
        function clearScene() {
            if (pointCloud) {
                scene.remove(pointCloud);
                pointCloud.geometry?.dispose();
                pointCloud.material?.dispose();
                pointCloud = null;
            }
            if (mesh) {
                scene.remove(mesh);
                mesh.geometry?.dispose();
                mesh.material?.dispose();
                mesh = null;
            }
            rfidMarkers.forEach(m => {
                scene.remove(m);
                m.geometry?.dispose();
                m.material?.dispose();
            });
            rfidMarkers = [];
            
            document.getElementById('point-count').textContent = '0';
            document.getElementById('face-count').textContent = '0';
            document.getElementById('rfid-count').textContent = '0';
        }
        
        // ============================================================
        // Load Assets
        // ============================================================
        async function loadPointCloud(jobId, filename = 'point_cloud.ply') {
            return new Promise((resolve, reject) => {
                // タイムアウト設定（5分）
                const timeout = setTimeout(() => {
                    reject(new Error('Point cloud loading timeout. The file may be too large.'));
                }, 300000);
                
                try {
                    const loader = new THREE.PLYLoader();
                    const url = `${API_BASE}/scenes/${jobId}/${filename}`;
                    
                    console.log('Loading point cloud from:', url);
                    showLoading('Loading point cloud (this may take a while for large files)...');
                    
                    loader.load(url,
                        (geometry) => {
                            try {
                                clearTimeout(timeout);
                                console.log('Point cloud loaded, processing...');
                                showLoading('Processing point cloud...');
                                
                                // デバッグ: geometryの状態を確認
                                console.log('Geometry type:', geometry.constructor.name);
                                console.log('Geometry attributes:', Object.keys(geometry.attributes));
                                
                                if (!geometry.attributes.position) {
                                    console.error('Geometry has no position attribute!');
                                    console.error('Available attributes:', Object.keys(geometry.attributes));
                                    throw new Error('Point cloud geometry has no position attribute');
                                }
                                
                                const positions = geometry.attributes.position;
                                console.log('Position attribute:', {
                                    count: positions ? positions.count : 'undefined',
                                    itemSize: positions ? positions.itemSize : 'undefined',
                                    array: positions ? positions.array : 'undefined',
                                    arrayLength: positions && positions.array ? positions.array.length : 'undefined'
                                });
                                
                                // メモリ使用量を監視しながら処理
                                const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                                
                                // 大きな点群の場合はダウンサンプリング（表示用）
                                const originalCount = positions ? positions.count : 0;
                                const MAX_POINTS = 500000; // 50万点まで（より安全な値）
                                
                                console.log(`Point cloud has ${originalCount.toLocaleString()} points`);
                                
                                if (originalCount === 0) {
                                    console.error('Point cloud has 0 points!');
                                    console.error('Position array:', positions ? positions.array : 'null');
                                    throw new Error('Point cloud has 0 points. The file may be corrupted or empty.');
                                }
                                
                                // computeBoundingBoxはposition属性があることを前提としている
                                geometry.computeBoundingBox();
                                
                                // Center
                                const center = new THREE.Vector3();
                                geometry.boundingBox.getCenter(center);
                                geometry.translate(-center.x, -center.y, -center.z);
                                
                                if (originalCount > MAX_POINTS) {
                                    console.log(`Point cloud too large (${originalCount.toLocaleString()} points), downsampling to ${MAX_POINTS.toLocaleString()}...`);
                                    showLoading(`Downsampling from ${originalCount.toLocaleString()} to ${MAX_POINTS.toLocaleString()} points...`);
                                    
                                    // チャンク処理でメモリ使用量を制限
                                    const step = Math.ceil(originalCount / MAX_POINTS);
                                    const targetCount = Math.min(MAX_POINTS, Math.floor(originalCount / step));
                                    
                                    // 新しいgeometryを作成（必要なサイズのみ）
                                    const newPositions = new Float32Array(targetCount * 3);
                                    const hasColors = geometry.attributes.color !== undefined;
                                    const newColors = hasColors ? new Float32Array(targetCount * 3) : null;
                                    
                                    // チャンク処理でダウンサンプリング
                                    const CHUNK_SIZE = 50000; // 5万点ずつ処理（メモリ使用量を削減）
                                    let newIndex = 0;
                                    
                                    for (let startIdx = 0; startIdx < originalCount && newIndex < targetCount; startIdx += CHUNK_SIZE) {
                                        const endIdx = Math.min(startIdx + CHUNK_SIZE, originalCount);
                                        
                                        for (let i = startIdx; i < endIdx && newIndex < targetCount; i += step) {
                                            newPositions[newIndex * 3] = positions.getX(i);
                                            newPositions[newIndex * 3 + 1] = positions.getY(i);
                                            newPositions[newIndex * 3 + 2] = positions.getZ(i);
                                            
                                            if (newColors && hasColors) {
                                                const color = geometry.attributes.color;
                                                newColors[newIndex * 3] = color.getX(i);
                                                newColors[newIndex * 3 + 1] = color.getY(i);
                                                newColors[newIndex * 3 + 2] = color.getZ(i);
                                            }
                                            
                                            newIndex++;
                                        }
                                        
                                        // メモリチェック
                                        if (performance.memory) {
                                            const currentMemory = performance.memory.usedJSHeapSize;
                                            if (currentMemory > startMemory * 3) {
                                                console.warn('High memory usage detected, stopping early');
                                                break;
                                            }
                                        }
                                        
                                        // 進捗更新（大きなファイルの場合）
                                        if (originalCount > 10000000 && startIdx % (CHUNK_SIZE * 10) === 0) {
                                            const progress = Math.floor((startIdx / originalCount) * 100);
                                            showLoading(`Downsampling: ${progress}% (${newIndex.toLocaleString()}/${targetCount.toLocaleString()} points)`);
                                        }
                                    }
                                    
                                    // 実際に使用したサイズに調整（必要に応じて）
                                    const finalCount = newIndex;
                                    
                                    // 古いgeometryを破棄（メモリ解放）
                                    geometry.dispose();
                                    
                                    // 新しいgeometryを作成
                                    geometry = new THREE.BufferGeometry();
                                    
                                    // 実際のサイズに合わせて配列を調整
                                    if (finalCount < targetCount) {
                                        const finalPositions = newPositions.slice(0, finalCount * 3);
                                        geometry.setAttribute('position', new THREE.BufferAttribute(finalPositions, 3));
                                        
                                        if (newColors) {
                                            const finalColors = newColors.slice(0, finalCount * 3);
                                            geometry.setAttribute('color', new THREE.BufferAttribute(finalColors, 3));
                                        }
                                    } else {
                                        geometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
                                        if (newColors) {
                                            geometry.setAttribute('color', new THREE.BufferAttribute(newColors, 3));
                                        }
                                    }
                                    
                                    geometry.computeBoundingBox();
                                    
                                    console.log(`Downsampled to ${finalCount.toLocaleString()} points`);
                                }
                                
                                // Colors (height-based if no vertex colors)
                                let colors = geometry.attributes.color;
                                
                                if (!colors) {
                                    showLoading('Generating colors...');
                                    const positions = geometry.attributes.position;
                                    const colorsArray = new Float32Array(positions.count * 3);
                                    const bbox = geometry.boundingBox;
                                    const minY = bbox.min.y, maxY = bbox.max.y;
                                    const rangeY = maxY - minY || 1;
                                    
                                    for (let i = 0; i < positions.count; i++) {
                                        const y = positions.getY(i);
                                        const t = (y - minY) / rangeY;
                                        const color = new THREE.Color();
                                        color.setHSL(0.5 - t * 0.3, 0.8, 0.5);
                                        colorsArray[i * 3] = color.r;
                                        colorsArray[i * 3 + 1] = color.g;
                                        colorsArray[i * 3 + 2] = color.b;
                                    }
                                    geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));
                                }
                                
                                const material = new THREE.PointsMaterial({
                                    size: 0.005,
                                    vertexColors: true,
                                    sizeAttenuation: true
                                });
                                
                                pointCloud = new THREE.Points(geometry, material);
                                scene.add(pointCloud);
                                
                                const pointCount = geometry.attributes.position.count;
                                document.getElementById('point-count').textContent = pointCount.toLocaleString();
                                
                                fitCameraToObject(pointCloud);
                                console.log('Point cloud loaded successfully');
                                resolve();
                            } catch (error) {
                                clearTimeout(timeout);
                                console.error('Error processing point cloud:', error);
                                reject(error);
                            }
                        },
                        (progress) => {
                            // ローディング進捗
                            if (progress.lengthComputable) {
                                const percent = (progress.loaded / progress.total) * 100;
                                showLoading(`Loading point cloud: ${percent.toFixed(1)}%`);
                                console.log(`Loading point cloud: ${percent.toFixed(1)}%`);
                            } else {
                                console.log('Loading point cloud (progress not computable)');
                            }
                        },
                        (error) => {
                            clearTimeout(timeout);
                            console.error('PLY load error:', error);
                            console.error('Error details:', {
                                message: error.message,
                                stack: error.stack,
                                type: error.constructor.name
                            });
                            reject(new Error(`Failed to load PLY file: ${error.message || 'Unknown error'}`));
                        }
                    );
                } catch (error) {
                    clearTimeout(timeout);
                    console.error('Error loading point cloud:', error);
                    reject(error);
                }
            });
        }
        
        async function loadMesh(jobId, filename = 'mesh.ply') {
            return new Promise(async (resolve, reject) => {
                // タイムアウト設定（3分、メッシュはより短く）
                const timeout = setTimeout(() => {
                    reject(new Error('Mesh loading timeout. The file may be too large.'));
                }, 180000);
                
                try {
                    const url = `${API_BASE}/scenes/${jobId}/${filename}`;
                    
                    console.log('Loading mesh from:', url);
                    
                    // ファイルサイズを事前にチェック
                    try {
                        const headResponse = await fetch(url, { method: 'HEAD' });
                        const contentLength = headResponse.headers.get('content-length');
                        
                        if (contentLength) {
                            const fileSizeMB = parseInt(contentLength) / (1024 * 1024);
                            console.log(`Mesh file size: ${fileSizeMB.toFixed(2)} MB`);
                            
                            // 500MB以上の場合は警告
                            if (fileSizeMB > 500) {
                                const shouldContinue = confirm(
                                    `警告: メッシュファイルが非常に大きいです (${fileSizeMB.toFixed(2)} MB)。\n` +
                                    `ブラウザがクラッシュする可能性があります。\n\n` +
                                    `ロードを続行しますか？`
                                );
                                
                                if (!shouldContinue) {
                                    clearTimeout(timeout);
                                    reject(new Error('User cancelled mesh loading due to large file size'));
                                    return;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Could not check file size:', e);
                    }
                    
                    showLoading('Loading mesh (this may take a while for large files)...');
                    
                    const loader = new THREE.PLYLoader();
                    
                    loader.load(url,
                        (geometry) => {
                            try {
                                clearTimeout(timeout);
                                console.log('Mesh loaded, processing...');
                                showLoading('Processing mesh...');
                                
                                // メモリチェック（ロード前）
                                if (performance.memory) {
                                    const usedMemory = performance.memory.usedJSHeapSize;
                                    const limitMemory = performance.memory.jsHeapSizeLimit;
                                    const memoryPercent = (usedMemory / limitMemory) * 100;
                                    
                                    console.log(`Memory usage before processing: ${memoryPercent.toFixed(1)}%`);
                                    
                                    if (memoryPercent > 70) {
                                        throw new Error('Memory usage too high. Please close other tabs and try again.');
                                    }
                                }
                                
                                geometry.computeVertexNormals();
                                geometry.computeBoundingBox();
                                
                                // Center
                                const center = new THREE.Vector3();
                                geometry.boundingBox.getCenter(center);
                                geometry.translate(-center.x, -center.y, -center.z);
                                
                                // 大きなメッシュの場合は警告
                                const MAX_TRIANGLES = 10000000; // 1000万三角形まで（実用的な上限）
                                const triangleCount = geometry.index ? geometry.index.count / 3 : 0;
                                
                                console.log(`Mesh has ${triangleCount.toLocaleString()} triangles`);
                                
                                if (triangleCount > MAX_TRIANGLES) {
                                    console.warn(`Mesh too large (${triangleCount.toLocaleString()} triangles), may cause memory issues`);
                                    showLoading(`Warning: Very large mesh (${triangleCount.toLocaleString()} triangles). Processing...`);
                                    
                                    // メモリチェック
                                    if (performance.memory) {
                                        const usedMemory = performance.memory.usedJSHeapSize;
                                        const limitMemory = performance.memory.jsHeapSizeLimit;
                                        const memoryPercent = (usedMemory / limitMemory) * 100;
                                        
                                        if (memoryPercent > 85) {
                                            geometry.dispose();
                                            throw new Error('Insufficient memory to process mesh. The mesh is too large for this browser.');
                                        }
                                    }
                                }
                                
                                const material = new THREE.MeshStandardMaterial({
                                    color: 0x00c896,
                                    roughness: 0.6,
                                    metalness: 0.2,
                                    flatShading: false,
                                    side: THREE.DoubleSide
                                });
                                
                                mesh = new THREE.Mesh(geometry, material);
                                mesh.visible = false;
                                scene.add(mesh);
                                
                                document.getElementById('face-count').textContent = Math.floor(triangleCount).toLocaleString();
                                
                                console.log('Mesh loaded successfully');
                                resolve();
                            } catch (error) {
                                clearTimeout(timeout);
                                console.error('Error processing mesh:', error);
                                
                                // メモリクリーンアップ
                                if (geometry) {
                                    try {
                                        geometry.dispose();
                                    } catch (e) {
                                        console.warn('Error disposing geometry:', e);
                                    }
                                }
                                
                                reject(error);
                            }
                        },
                        (progress) => {
                            // ローディング進捗
                            if (progress.lengthComputable) {
                                const percent = (progress.loaded / progress.total) * 100;
                                showLoading(`Loading mesh: ${percent.toFixed(1)}%`);
                                console.log(`Loading mesh: ${percent.toFixed(1)}%`);
                                
                                // メモリチェック（ロード中）
                                if (performance.memory && percent > 50) {
                                    const usedMemory = performance.memory.usedJSHeapSize;
                                    const limitMemory = performance.memory.jsHeapSizeLimit;
                                    const memoryPercent = (usedMemory / limitMemory) * 100;
                                    
                                    if (memoryPercent > 90) {
                                        console.warn('Memory usage very high during loading, aborting...');
                                        loader.manager.itemError(url);
                                        clearTimeout(timeout);
                                        reject(new Error('Memory usage too high during loading. Please try a smaller mesh.'));
                                    }
                                }
                            }
                        },
                        (error) => {
                            clearTimeout(timeout);
                            console.error('Mesh load error:', error);
                            reject(error);
                        }
                    );
                } catch (error) {
                    clearTimeout(timeout);
                    console.error('Error loading mesh:', error);
                    reject(error);
                }
            });
        }
        
        async function loadRFID(jobId) {
            try {
                const response = await fetch(`${API_BASE}/scenes/${jobId}/rfid_positions.json`);
                const data = await response.json();
                
                const rfidList = document.getElementById('rfid-list');
                rfidList.innerHTML = '';
                
                // データ構造の対応: detections または tags
                const detections = data.detections || data.tags || [];
                
                if (detections.length === 0) {
                    rfidList.innerHTML = '<div style="color: #666; font-size: 11px;">No RFID data</div>';
                    document.getElementById('rfid-count').textContent = '0';
                    return;
                }
                
                detections.forEach((detection, index) => {
                    // Create marker
                    const geometry = new THREE.SphereGeometry(0.03, 16, 16);
                    const material = new THREE.MeshBasicMaterial({ color: 0xff6600 });
                    const marker = new THREE.Mesh(geometry, material);
                    
                    // 位置情報の取得（position または pose.position）
                    if (detection.position) {
                        marker.position.set(detection.position.x, detection.position.y, detection.position.z);
                    } else if (detection.pose && detection.pose.position) {
                        marker.position.set(detection.pose.position.x, detection.pose.position.y, detection.pose.position.z);
                    }
                    
                    marker.visible = false;
                    scene.add(marker);
                    rfidMarkers.push(marker);
                    
                    // Add to list
                    const item = document.createElement('div');
                    item.className = 'rfid-item';
                    const tagId = detection.tag_id || detection.epc || `Tag ${index + 1}`;
                    const rssi = detection.rssi !== undefined ? `${detection.rssi} dBm` : 'N/A';
                    item.innerHTML = `
                        <div class="rfid-epc">${tagId}</div>
                        <div class="rfid-rssi">RSSI: ${rssi}</div>
                    `;
                    rfidList.appendChild(item);
                });
                
                document.getElementById('rfid-count').textContent = detections.length.toString();
                
            } catch (error) {
                console.error('RFID load error:', error);
            }
        }
        
        // ============================================================
        // Trajectory Loading
        // ============================================================
        let trajectoryLine = null;
        let trajectoryMarkers = [];
        
        async function loadTrajectory(jobId) {
            try {
                const response = await fetch(`${API_BASE}/scenes/${jobId}/trajectory.json`);
                if (!response.ok) {
                    console.log('Trajectory data not available');
                    document.getElementById('trajectory-count').textContent = '0';
                    return;
                }
                
                const data = await response.json();
                const poses = data.poses || [];
                
                if (poses.length === 0) {
                    document.getElementById('trajectory-count').textContent = '0';
                    return;
                }
                
                // Create trajectory line
                const points = poses.map(pose => new THREE.Vector3(pose.x, pose.y, pose.z));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x00ff00,  // Green color for trajectory
                    linewidth: 2
                });
                trajectoryLine = new THREE.Line(geometry, material);
                trajectoryLine.visible = false;
                scene.add(trajectoryLine);
                
                // Create start/end markers
                // Start marker (green sphere)
                const startGeometry = new THREE.SphereGeometry(0.05, 16, 16);
                const startMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const startMarker = new THREE.Mesh(startGeometry, startMaterial);
                startMarker.position.copy(points[0]);
                startMarker.visible = false;
                scene.add(startMarker);
                trajectoryMarkers.push(startMarker);
                
                // End marker (red sphere)
                const endGeometry = new THREE.SphereGeometry(0.05, 16, 16);
                const endMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const endMarker = new THREE.Mesh(endGeometry, endMaterial);
                endMarker.position.copy(points[points.length - 1]);
                endMarker.visible = false;
                scene.add(endMarker);
                trajectoryMarkers.push(endMarker);
                
                // Add intermediate markers every N poses
                const markerInterval = Math.max(1, Math.floor(poses.length / 20));
                for (let i = markerInterval; i < poses.length - 1; i += markerInterval) {
                    const markerGeometry = new THREE.SphereGeometry(0.02, 8, 8);
                    const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.copy(points[i]);
                    marker.visible = false;
                    scene.add(marker);
                    trajectoryMarkers.push(marker);
                }
                
                document.getElementById('trajectory-count').textContent = poses.length.toString();
                document.getElementById('btn-trajectory').disabled = false;
                
                console.log(`Trajectory loaded: ${poses.length} poses`);
                
            } catch (error) {
                console.error('Trajectory load error:', error);
                document.getElementById('trajectory-count').textContent = '0';
            }
        }
        
        // ============================================================
        // Display Modes
        // ============================================================
        function setDisplayMode(mode) {
            displayMode = mode;
            
            // Update buttons
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');
            
            // Update visibility
            if (pointCloud) pointCloud.visible = (mode === 'pointcloud');
            if (mesh) mesh.visible = (mode === 'mesh');
            rfidMarkers.forEach(m => m.visible = (mode === 'rfid'));
            if (trajectoryLine) trajectoryLine.visible = (mode === 'trajectory');
            trajectoryMarkers.forEach(m => m.visible = (mode === 'trajectory'));
            
            // Show RFID with other modes if selected
            if (mode === 'rfid') {
                if (pointCloud) pointCloud.visible = true;
                rfidMarkers.forEach(m => m.visible = true);
            }
            
            // Show trajectory with mesh or pointcloud
            if (mode === 'trajectory') {
                if (mesh) mesh.visible = true;
                else if (pointCloud) pointCloud.visible = true;
                if (trajectoryLine) trajectoryLine.visible = true;
                trajectoryMarkers.forEach(m => m.visible = true);
            }
        }
        
        // ============================================================
        // Camera
        // ============================================================
        function fitCameraToObject(object) {
            const bbox = new THREE.Box3().setFromObject(object);
            const center = bbox.getCenter(new THREE.Vector3());
            const size = bbox.getSize(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.5;
            
            camera.position.set(center.x + cameraZ * 0.5, center.y + cameraZ * 0.5, center.z + cameraZ);
            controls.target.copy(center);
            controls.update();
        }
        
        // ============================================================
        // Event Handlers
        // ============================================================
        document.getElementById('job-select').addEventListener('change', (e) => {
            loadJob(e.target.value);
        });
        
        document.getElementById('btn-pointcloud').addEventListener('click', () => setDisplayMode('pointcloud'));
        document.getElementById('btn-mesh').addEventListener('click', () => setDisplayMode('mesh'));
        document.getElementById('btn-rfid').addEventListener('click', () => setDisplayMode('rfid'));
        document.getElementById('btn-trajectory').addEventListener('click', () => setDisplayMode('trajectory'));
        
        // ============================================================
        // Global Error Handlers
        // ============================================================
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            if (event.error && (event.error.message.includes('memory') || event.error.message.includes('allocation'))) {
                showLoading('Memory error: The point cloud is too large. Please try loading the mesh instead.');
                setTimeout(() => hideLoading(), 5000);
            }
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            if (event.reason && (event.reason.message && (event.reason.message.includes('memory') || event.reason.message.includes('timeout')))) {
                showLoading('Error: ' + event.reason.message);
                setTimeout(() => hideLoading(), 5000);
            }
        });
        
        // ============================================================
        // Initialize
        // ============================================================
        initViewer();
        loadJobList();
    </script>
</body>
</html>

